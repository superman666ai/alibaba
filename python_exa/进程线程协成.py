# -*- coding: utf-8 -*-

# @Time    : 2019-03-20 16:47
# @Author  : jian
# @File    : 进程线程协成.py

"""
1.谈谈你对多进程，多线程，以及协程的理解，项目是否用？(2018-3-30-lxy)
这个问题被问的概率相当之大，其实多线程，多进程，在实际开发中用到的很少，除非是那些对项目性能要求特别高的，
有的开发工作几年了，也确实没用过，你可以这么回答，给他扯扯什么是进程，线程（cpython中是伪多线程）的概念就行，
实在不行你就说你之前写过下载文件时，用过多线程技术，或者业余时间用过多线程写爬虫，提升效率。
进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，
进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。
线程：  调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在一个进程至少有一个线程，叫主线程，
而多个线程共享内存(数据共享，共享全局变量)，从而极大地提高了程序的运行效率。
协程：是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。
协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈
，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

2.什么是多线程竞争？(2018-3-30-lxy)
线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：
数据几乎同步会被多个线程占用，造成数据混乱 ，即所谓的线程不安全
那么怎么解决多线程竞争问题？-- 锁。
锁的好处：
确保了某段关键代码(共享数据资源)只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。
锁的坏处：
阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
锁的致命问题：死锁。
3.什么是死锁？(2018-3-30-lxy)
若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。
GIL锁（有时候，面试官不问，你自己要主动说，增加b格，尽量别一问一答的尬聊，不然最后等到的一句话就是：你还有什么想问的么？）
GIL锁 全局解释器锁（只在cpython里才有）
作用：限制多线程同时执行，保证同一时间只有一个线程执行，所以cpython里的多线程其实是伪多线程!
所以Python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程，
进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作才会切换。
三者的关系：进程里有线程，线程里有协程。
4.什么是线程安全，什么是互斥锁？(2018-3-30-lxy)
每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
同一个进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，
另一个线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。

5.说说下面几个概念：同步，异步，阻塞，非阻塞?(2018-3-30-lxy)
同步：多个任务之间有先后顺序执行，一个执行完下个才能执行。
异步：多个任务之间没有先后顺序，可以同时执行有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！
阻塞：如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。
非阻塞：如果不会卡住，可以继续执行，就是说非阻塞的。
同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。

6.怎么避免僵尸进程? (2018-3-30-lxy)
1.fork两次用孙子进程去完成子进程的任务；
2.用wait()函数使父进程阻塞；
3.使用信号量，在 signal handler 中调用waitpid，这样父进程不用阻塞。

7.Python中的进程与线程的使用场景? (2018-3-30-lxy)
多进程适合在 CPU 密集型操作(cpu 操作指令比较多，如位数多的浮点运算)。
多线程适合在 IO 密集型操作(读写数据操作较多的，比如爬虫)。

8.线程是并发还是并行，进程是并发还是并行？(2018-3-30-lxy)
线程是并发，进程是并行；
进程之间相互独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源。

9.并行（parallel）和并发（concurrency）？(2018-3-30-lxy)
并行：同一时刻多个任务同时在运行。
并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况。

实现并行的库有：multiprocessing
实现并发的库有：threading

程序需要执行较多的读写、请求和回复任务的需要大量的 IO 操作，IO密集型操作使用并发更好。
CPU运算量大的程序程序，使用并行会更好。

10.IO密集型和CPU密集型区别？(2018-4-16-lxy)
IO密集型：系统运作，大部分的状况是CPU在等 I/O (硬盘/内存)的读/写。
CPU密集型：大部份时间用来做计算、逻辑判断等 CPU动作的程序称之CPU密集型。
"""